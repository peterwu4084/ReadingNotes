# 异常处理

增强错误恢复能力是提高代码健壮性的最有力途径之一。

C语言中异常处理是“紧耦合”的：必须在靠近函数调用的地方编写异常处理代码。

C++异常处理：

1. 异常处理代码不再冗长乏味，可以在任何地方编写。

2. 错误不能被忽略。如果异常没有被处理，会层层上传，直到异常被处理或程序终止。

## 传统异常处理

开发阶段使用 `assert` 调试，发行使用 `#define NDEBUG` 使其失效。

1. 知道应该做什么时，在异常发生时立即处理。

2. 无法处理时：

   1. 在函数中返回错误信息，或设置全局错误状态标志。

   2. 使用标准c库中的信号处理系统（ `signal` 或 `raise` ）。耦合度高，可能和其他库的信号值冲突。

   3. 使用标准c库中的非局部跳转函数（ `setjmp` 和 `longjmp` ）。错误发生的位置和跳转位置高度耦合，对象不会正确清理，程序行为无法预知。

## 抛出异常

程序出现异常，且当前语境无法处理，可以创建一个包含错误信息的对象并抛到更大的语境中。

关键词 `throw`：它将创建抛出对象的拷贝，然后包含 `throw` 的函数返回这个对象，即使该函数并非设计返回此对象类型。程序将返回到函数调用的位置。异常发生前创建的局部对象被自动销毁（栈反解），如果局部对象的构造函数抛出异常，那么该局部对象的析构函数不会被调用。

典型做法：不同的异常抛出不同类型的对象，保存相应的错误信息。

## 捕获异常

可以在抛出异常的地方设置一个 `try` 块，为每一种异常设置一个 `catch` 块来捕获和处理它。

``` cpp
try {
  // 可能抛出异常的代码
} catch (type1 id1) {
  // 处理type1异常
} catch (type2 id2) {
  // 处理type2异常
} catch (type3) {
  // 处理type3异常
}
```

`catch` 的语法类似带有单一参数的函数，可以在 `catch` 块中使用标识符（id1、id2），如果 `catch` 中不需要使用标识符，可以省略（type3）。

当某个异常被抛出，异常处理机制会依次寻找参数类型匹配的 `catch` 块，如果找到，程序会执行 `catch` 块中的代码，并认为该异常已被处理，并恢复到正常的执行流程。

## 异常匹配

异常匹配中，一个对象或派生类引用都会与其基类匹配。为避免异常对象拷贝，最后通过引用而不是值捕获异常。

如果一个指针被抛出，将使用通常的标准指针转换来匹配，派生类的指针也会与基类指针匹配。

匹配过程中，不会自动将一种异常类型转换成另一种（非继承）。

`catch(...)` 可以捕获所有异常。

在 `catch` 块中，可以使用不带参数的 `throw` 重新抛出异常。

如果异常没有被捕获，一个特殊的库函数 `terminate` 会被调用 （头文件 `<exception>`中定义）。局部对象的析构函数、全局对象和静态对象的构造函数和析构函数抛出异常，也会调用 `terminate`。

可以使用 `set_terminate` 设置自己的 `terminate` 函数，`set_terminate` 接受一个函数的指针，返回当前 `terminate` 函数的指针。自定义的 `terminate` 函数不能有参数，返回值必须是 `void`。

## 清理

如果一个对象的构造函数抛出异常，那么该对象的析构函数不会被调用，此时析构函数没有机会释放构造函数已分配的资源。为了防止资源泄露，必须采用以下两种方式分配资源：

- 在构造函数中捕获异常，用于释放资源。

- 在对象的构造函数中分配资源，并在析构函数中释放资源。

## 标准异常

标准C++库中定义了标准异常类，使用方便快捷。所有标准异常类都是从 `exception` 类派生的（定义在头文件 `<exception>` 中）。

`exception` 类的两个主要派生类为 `logic_error` 和 `runtime_error` （定义在头文件 `<stdexcept>` 中）。

- `logic_error` 用于描述程序中出现的逻辑错误

- `runtime_error` 是指那些无法预料的事件所造成的错误

二者都提供了一个参数类型为 `std::string` 的构造函数，用于保存错误信息。通过 `exception::what` 函数，可以从异常对象中得到保存的信息。（但是 `exception` 类没有提供类似的构造函数。）

## 异常规格说明

C++提供一种语法来告诉使用者函数所抛出的异常：异常规格说明。它是函数声明的修饰符，写在参数列表后面，函数可能抛出的所有可能的异常类型被写在 `throw` 之后的括号中，函数声明如下所示：

```cpp
void f() throw(toobig, toosmall, divzero);
void g(); // 可能抛出任何类型的异常
void g() throw(); // 不会抛出任何类型的异常
```

如果函数所抛出的异常没有在异常规格说明的异常集中，特殊函数 `unexpected()` 会被调用，默认的 `unexpected()` 函数会调用 `terminate()` 函数。

和 `terminate()` 函数类似，`set_unexpected()` 函数可以设置自己的 `unexpected()` 函数，它的参数是一个函数指针，函数指针所指向的函数不能有参数，且返回值类型为void。同样，`set_unexpected` 返回修改前的 `unexpected` 的函数指针。

当无法得知会触发什么异常时，不要使用异常规格说明。

## 何时避免使用异常

1. 不要在异步事件中使用异常

2. 不要在处理简单错误时使用异常

3. 不要将异常用于程序的流程控制

4. 不要强迫自己使用异常

5. 新异常，老代码

## 何时使用异常

1. 修正错误并且重新调试产生异常的函数

2. 在重新调试中的函数外面补偿一些行为使程序得以继续执行

3. 在当前语境中做尽可能多的事情，把相同类型的异常抛出到更高层语境中

4. 在当前语境中做尽可能多的事情，把不同类型的异常抛出到更高层语境中

5. 终止程序

6. 简化错误处理

7. 使用库和程序更安全
